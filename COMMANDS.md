# Commands

### archive

  - [archive compress tar.gz , archive tar.gz](#archive-compress-tar.gz-,-archive-tar.gz)

  - [archive compress tar.xz , archive tar.xz](#archive-compress-tar.xz-,-archive-tar.xz)

  - [archive compress .zip , archive zip](#archive-compress-.zip-,-archive-zip)

  - [archive decompress tar.gz , decompress tar.gz](#archive-decompress-tar.gz-,-decompress-tar.gz)

  - [archive decompress tar.xz , decompress tar.xz](#archive-decompress-tar.xz-,-decompress-tar.xz)

  - [archive decompress .zip , archive unzip](#archive-decompress-.zip-,-archive-unzip)

### array

  - [array all](#array-all)

  - [array at index](#array-at-index)

  - [array concat](#array-concat)

  - [array contains](#array-contains)

  - [array declare](#array-declare)

  - [array delete](#array-delete)

  - [array delete at](#array-delete-at)

  - [array filter](#array-filter)

  - [array iterate , array forEach](#array-iterate-,-array-forEach)

  - [array length](#array-length)

  - [array push , array add](#array-push-,-array-add)

  - [array slice , array range](#array-slice-,-array-range)

  - [array replace](#array-replace)

  - [array reverse](#array-reverse)

  - [array set element](#array-set-element)

### command

  - [command failure check , cmd failure check](#command-failure-check-,-cmd-failure-check)

  - [hide command error , don't show command error](#hide-command-error-,-don't-show-command-error)

  - [if command exists , if cmd exists](#if-command-exists-,-if-cmd-exists)

  - [command nice , cmd nice](#command-nice-,-cmd-nice)

  - [command renice , cmd renice](#command-renice-,-cmd-renice)

  - [command , cmd , command substitution , cmd substitution](#command-,-cmd-,-command-substitution-,-cmd-substitution)

  - [command success check , cmd success check](#command-success-check-,-cmd-success-check)

### cryptography

  - [crypto base64 decode](#crypto-base64-decode)

  - [crypto base64 encode](#crypto-base64-encode)

  - [crypto hash](#crypto-hash)

### date

  - [date now dayOfMonth](#date-now-dayOfMonth)

  - [date now dayOfWeek](#date-now-dayOfWeek)

  - [date now dayOfYear](#date-now-dayOfYear)

  - [date now short](#date-now-short)

  - [date now monthName](#date-now-monthName)

  - [date now monthNumber](#date-now-monthNumber)

  - [date now UTC](#date-now-UTC)

  - [date now year](#date-now-year)

### event

  - [event CTRL+C , event terminated](#event-CTRL+C-,-event-terminated)

  - [event EXIT](#event-EXIT)

### filesystem

  - [iterate directories](#iterate-directories)

  - [directory create](#directory-create)

  - [directory create nested](#directory-create-nested)

  - [directory delete nested , directory remove nested](#directory-delete-nested-,-directory-remove-nested)

  - [file delete , file remove](#file-delete-,-file-remove)

  - [file read](#file-read)

  - [file search , search in files , find in files](#file-search-,-search-in-files-,-find-in-files)

  - [file write](#file-write)

  - [file write multiline](#file-write-multiline)

  - [file write multiline sudo](#file-write-multiline-sudo)

  - [iterate files](#iterate-files)

  - [file find , directory find](#file-find-,-directory-find)

  - [if directory exists](#if-directory-exists)

  - [if file executable](#if-file-executable)

  - [if file exists](#if-file-exists)

  - [if file link](#if-file-link)

  - [if file not empty](#if-file-not-empty)

  - [if file readable](#if-file-readable)

  - [if file writeable](#if-file-writeable)

  - [if file newer](#if-file-newer)

  - [if file older](#if-file-older)

  - [if file =](#if-file-=)

  - [if path exists](#if-path-exists)

  - [remove old/new files/directories](#remove-old/new-files/directories)

  - [remove old files](#remove-old-files)

### float

  - [if float = , if double =](#if-float-=-,-if-double-=)

  - [if float > , if double >](#if-float->-,-if-double->)

  - [if float >= , if double >=](#if-float->=-,-if-double->=)

  - [if float < , if double <](#if-float-<-,-if-double-<)

  - [if float <= , if double <=](#if-float-<=-,-if-double-<=)

  - [if float != , if double !=](#if-float-!=-,-if-double-!=)

### fn-fx

  - [fn animation animate](#fn-animation-animate)

  - [fn animation pacman](#fn-animation-pacman)

  - [fn banner color](#fn-banner-color)

  - [fn banner simple](#fn-banner-simple)

  - [fn import](#fn-import)

  - [fn options , fn input choice](#fn-options-,-fn-input-choice)

  - [fn checkbox , fn input multichoice](#fn-checkbox-,-fn-input-multichoice)

  - [fn math average](#fn-math-average)

  - [fn math factorial](#fn-math-factorial)

  - [fn math fibonacci](#fn-math-fibonacci)

  - [fn math fibonacci series](#fn-math-fibonacci-series)

  - [fn math product](#fn-math-product)

  - [fn math sum](#fn-math-sum)

  - [fn progress](#fn-progress)

  - [fn scan local](#fn-scan-local)

  - [fn time format seconds](#fn-time-format-seconds)

  - [fn urldecode](#fn-urldecode)

  - [fn urlencode](#fn-urlencode)

  - [fn version compare , fn semver compare](#fn-version-compare-,-fn-semver-compare)

  - [fx animation animate](#fx-animation-animate)

  - [fx animation pacman](#fx-animation-pacman)

  - [fx banner color](#fx-banner-color)

  - [fx banner simple](#fx-banner-simple)

  - [fx import](#fx-import)

  - [fx options , fx input choice](#fx-options-,-fx-input-choice)

  - [fx checkbox , fx input multichoice](#fx-checkbox-,-fx-input-multichoice)

  - [fx math fibonacci](#fx-math-fibonacci)

  - [fx math average](#fx-math-average)

  - [fx math factorial](#fx-math-factorial)

  - [fx math fibonacci series](#fx-math-fibonacci-series)

  - [fx math product](#fx-math-product)

  - [fx math sum](#fx-math-sum)

  - [fx progress](#fx-progress)

  - [fx scan local](#fx-scan-local)

  - [fx time format seconds](#fx-time-format-seconds)

  - [fx urldecode](#fx-urldecode)

  - [fx urlencode](#fx-urlencode)

  - [fx version compare , fx semver compare](#fx-version-compare-,-fx-semver-compare)

### ftp

  - [ftp delete file](#ftp-delete-file)

  - [ftp download](#ftp-download)

  - [ftp list](#ftp-list)

  - [ftp rename](#ftp-rename)

  - [ftp upload](#ftp-upload)

### function

  - [function arguments , func args](#function-arguments-,-func-args)

  - [function arguments count , func args count](#function-arguments-count-,-func-args-count)

  - [function , func](#function-,-func)

  - [function return value , func return value](#function-return-value-,-func-return-value)

### git

  - [git branch create](#git-branch-create)

  - [git branch delete local](#git-branch-delete-local)

  - [git branch delete remote](#git-branch-delete-remote)

  - [git branch list](#git-branch-list)

  - [git branch push](#git-branch-push)

  - [git branch rename](#git-branch-rename)

  - [git changes revert](#git-changes-revert)

  - [git clone](#git-clone)

  - [git clone branch](#git-clone-branch)

  - [git commit](#git-commit)

  - [git commit list notPushed](#git-commit-list-notPushed)

  - [git commit search](#git-commit-search)

  - [git commit undo](#git-commit-undo)

  - [git config list](#git-config-list)

  - [git config set](#git-config-set)

  - [git patch apply](#git-patch-apply)

  - [git patch create](#git-patch-create)

  - [git remote list](#git-remote-list)

  - [git remote urlChange](#git-remote-urlChange)

  - [git remote urlAdd](#git-remote-urlAdd)

  - [git tag commit , git commit tag](#git-tag-commit-,-git-commit-tag)

  - [git tag list](#git-tag-list)

  - [git tag remote delete](#git-tag-remote-delete)

  - [git tag remote push](#git-tag-remote-push)

### http

  - [http cookie](#http-cookie)

  - [http download](#http-download)

  - [http GET , http DELETE](#http-GET-,-http-DELETE)

  - [http header](#http-header)

  - [http POST , http PUT](#http-POST-,-http-PUT)

  - [http POST file](#http-POST-file)

### input

  - [input password](#input-password)

  - [input text , ask question](#input-text-,-ask-question)

### integer

  - [if int =](#if-int-=)

  - [if int >](#if-int->)

  - [if int >=](#if-int->=)

  - [if int <](#if-int-<)

  - [if int <=](#if-int-<=)

  - [if int !=](#if-int-!=)

### internal

  - [for i](#for-i)

  - [for ij](#for-ij)

  - [for in collection](#for-in-collection)

  - [for in column](#for-in-column)

  - [for in range](#for-in-range)

  - [if](#if)

  - [iff](#iff)

  - [iff not](#iff-not)

  - [loop infinite](#loop-infinite)

  - [switch case](#switch-case)

  - [loop until](#loop-until)

  - [loop while](#loop-while)

### ip

  - [ip local IPs](#ip-local-IPs)

  - [ip info](#ip-info)

  - [ip public](#ip-public)

### math

  - [math +](#math-+)

  - [math const ð›¾](#math-const-ð›¾)

  - [math const e](#math-const-e)

  - [math const Î©](#math-const-Î©)

  - [math const Ï•](#math-const-Ï•)

  - [math const Ï€](#math-const-Ï€)

  - [math --](#math---)

  - [math /](#math-/)

  - [math /=](#math-/=)

  - [expr , arithmetic](#expr-,-arithmetic)

  - [math ++](#math-++)

  - [let](#let)

  - [math -=](#math--=)

  - [math %](#math-%)

  - [math %=](#math-%=)

  - [math *](#math-*)

  - [math *=](#math-*=)

  - [math +=](#math-+=)

  - [math ^](#math-^)

  - [math 0.00](#math-0.00)

  - [math random](#math-random)

  - [math âˆš , math sqrt](#math-âˆš-,-math-sqrt)

  - [math -](#math--)

### misc

  - [am I not root , am I not sudo](#am-I-not-root-,-am-I-not-sudo)

  - [am I root , am I sudo](#am-I-root-,-am-I-sudo)

  - [animation frame](#animation-frame)

  - [argument parsing , parse args](#argument-parsing-,-parse-args)

  - [echo array](#echo-array)

  - [echo text , print text](#echo-text-,-print-text)

  - [echo variable , print variable](#echo-variable-,-print-variable)

  - [exit code](#exit-code)

  - [region , section](#region-,-section)

  - [shebang , bash , first line](#shebang-,-bash-,-first-line)

  - [sleep](#sleep)

  - [stopwatch elapsed](#stopwatch-elapsed)

  - [stopwatch start](#stopwatch-start)

  - [stopwatch stop](#stopwatch-stop)

  - [summary](#summary)

  - [timeout](#timeout)

### output

  - [color black](#color-black)

  - [color blue](#color-blue)

  - [color cyan](#color-cyan)

  - [color green](#color-green)

  - [color magenta](#color-magenta)

  - [color red](#color-red)

  - [color white](#color-white)

  - [color yellow](#color-yellow)

  - [format bold](#format-bold)

  - [format dim](#format-dim)

  - [format italic](#format-italic)

  - [format reverse](#format-reverse)

### process

  - [process ID(s)](#process-ID(s))

  - [process instances](#process-instances)

  - [process kill](#process-kill)

  - [process list all](#process-list-all)

  - [process Name by ID](#process-Name-by-ID)

### string

  - [string concat , string + string](#string-concat-,-string-+-string)

  - [string contains , if string contains](#string-contains-,-if-string-contains)

  - [string indexOf](#string-indexOf)

  - [if string empty](#if-string-empty)

  - [if string = , string equal](#if-string-=-,-string-equal)

  - [if string not empty](#if-string-not-empty)

  - [if string != , string not equal](#if-string-!=-,-string-not-equal)

  - [string length](#string-length)

  - [string random](#string-random)

  - [string replace](#string-replace)

  - [string reverse](#string-reverse)

  - [string substring](#string-substring)

  - [string substring count , string substring frequency](#string-substring-count-,-string-substring-frequency)

  - [string toLower](#string-toLower)

  - [string toUpper](#string-toUpper)

  - [string trim](#string-trim)

  - [string trim all](#string-trim-all)

  - [string trim left](#string-trim-left)

  - [string trim right](#string-trim-right)

### system

  - [system distro codename](#system-distro-codename)

  - [system distro name](#system-distro-name)

  - [system distro version](#system-distro-version)

  - [system kernel name](#system-kernel-name)

  - [system kernel release](#system-kernel-release)

  - [system memory info](#system-memory-info)

  - [system processor architecture , system cpu architecture , system cpu arch](#system-processor-architecture-,-system-cpu-architecture-,-system-cpu-arch)

  - [system processor count , system cpu count](#system-processor-count-,-system-cpu-count)

  - [system processor model , system cpu model](#system-processor-model-,-system-cpu-model)

  - [system processor type , system cpu type](#system-processor-type-,-system-cpu-type)

  - [service manage , systemd manage](#service-manage-,-systemd-manage)

  - [system uptime](#system-uptime)

  - [system uptime seconds](#system-uptime-seconds)

### time

  - [time seconds epoch](#time-seconds-epoch)

  - [time now local](#time-now-local)

  - [time now UTC](#time-now-UTC)

### variable

  - [variable assign , variable set](#variable-assign-,-variable-set)

  - [variable default value , assign if empty](#variable-default-value-,-assign-if-empty)

  - [var , variable read , variable expand](#var-,-variable-read-,-variable-expand)

## archive compress tar.gz , archive tar.gz

compress file/folder to a .tar.gz file [&uarr;](#Commands)

```bash
tar -czvf ${1|/path/to/archive, "${pathToArchive}"|}.tar.gz ${2|/path/to/directory-or-file, "${pathToDirectoryOrFile}"|}
```



## archive compress tar.xz , archive tar.xz

compress file/folder to a .tar.xz file [&uarr;](#Commands)

```bash
tar -cJf ${1|/path/to/archive, "${pathToArchive}"|}.tar.xz ${2|/path/to/directory-or-file, "${pathToDirectoryOrFile}"|}
```



## archive compress .zip , archive zip

compress file/folder to a .zip file [&uarr;](#Commands)

```bash
zip -rq ${1|/path/to/archive, "${pathToArchive}"|}.zip ${2|/path/to/directory-or-file,"${pathToDirectoryOrFile}"|}
```



## archive decompress tar.gz , decompress tar.gz

decompress a .tar.gz file to specified path [&uarr;](#Commands)

```bash
tar -C ${1|/extract/to/path, "${extractToPath}"|} -xzvf ${2|/path/to/archive, "${pathToArchive}"|}.tar.gz
```



## archive decompress tar.xz , decompress tar.xz

decompress a .tar.xz file to specified path [&uarr;](#Commands)

```bash
tar -C ${1|/extract/to/path, "${extractToPath}"|} -xf ${2|/path/to/archive, "${pathToArchive}"|}.tar.xz
```



## archive decompress .zip , archive unzip

decompress a .zip file to specified path [&uarr;](#Commands)

```bash
unzip -q ${1|/path/to/archive, "${pathToArchive}"|}.zip -d ${2|/extract/to/path,"${extractToPath}"|}
```



## array all

access all array elements [&uarr;](#Commands)

```bash
echo "${${1:myArray}[@]}"
```



## array at index

retrieve element from array at specified index (zero based) [&uarr;](#Commands)

```bash
echo "${${1:myArray}[index]}"
```



## array concat

concatenate two arrays [&uarr;](#Commands)

```bash
newArray=("${array1[@]}" "${array2[@]}")
```



## array contains

check if the array contains an element [&uarr;](#Commands)

```bash
if [[ "${myArray[@]}" =~ ${2|'element',"${value}"|} ]]; then
  echo 'array contains element'
fi
```



## array declare

declare an array [&uarr;](#Commands)

```bash
myArray=(
  'constant'
  "${variable}"
  'another constant'
)
```



## array delete

delete entire array [&uarr;](#Commands)

```bash
unset myArray
```



## array delete at

delete element at index from array [&uarr;](#Commands)

```bash
unset myArray[${2:index}]
```



## array filter

filter elements of an array based on given grep pattern [&uarr;](#Commands)

```bash
filtered=($(for i in ${myArray[@]} ; do echo ${i}; done | grep ${3|',"|}pattern${3}))
```



## array iterate , array forEach

iterate array elements [&uarr;](#Commands)

```bash
for item in "${myArray[@]}"; do
  echo "${item"}
done
```



## array length

length of an array [&uarr;](#Commands)

```bash
length=${#${2:myArray}[@]}
```



## array push , array add

push new item to the end of array [&uarr;](#Commands)

```bash
myArray+=('${2:newItem}')
```



## array slice , array range

n elements of an array from specified index (zero based) [&uarr;](#Commands)

```bash
newArray="${${2:myArray}[@]:fromIndex:${4:n}}"
```



## array replace

find and replace elements in array using regex [&uarr;](#Commands)

```bash
newArray=${${2:myArray}[@]//find/${4:replace}}
```



## array reverse

reverse order of array elements [&uarr;](#Commands)

```bash
reversedArray=( $(echo "${array[@]}" | rev) )
```



## array set element

set array element at specified index [&uarr;](#Commands)

```bash
myArray[${2:index}]="value"
```



## command failure check , cmd failure check

check if last command failed [&uarr;](#Commands)

```bash
if [[ $? != 0 ]]; then
  echo "Last command failed"
fi
```



## hide command error , don't show command error

If a command fails don't show error (suppress stderr) [&uarr;](#Commands)

```bash
command 2> /dev/null
```



## if command exists , if cmd exists

check if command exists [&uarr;](#Commands)

```bash
if [ $(command -v command) ]; then
  echo "command \"${1:command\" exists on system"}
fi
```



## command nice , cmd nice

run command with desired privilege. n: -20 (highest priority) to 19 (lowest priority) [&uarr;](#Commands)

```bash
sudo nice -n ${1|-20,-15,-10,-5,0,5,10,15,19|} command
```



## command renice , cmd renice

change running process priority. n: -20 (highest priority) to 19 (lowest priority) [&uarr;](#Commands)

```bash
for p in $(pidof "processName"); do sudo renice -n ${2|-20,-15,-10,-5,0,5,10,15,19|} -p "$p"; done
```



## command , cmd , command substitution , cmd substitution

run command (command substitution) [&uarr;](#Commands)

```bash
result="$(${2:command})"
```



## command success check , cmd success check

check if last command succeed [&uarr;](#Commands)

```bash
if [[ $? == 0 ]]; then
  echo "Last command succeed"
fi
```



## crypto base64 decode

decode variable from base64 [&uarr;](#Commands)

```bash
base64Decoded=$(echo -n "${2|stringToDecode,${variableToDecode}|}" | base64 -d)
```



## crypto base64 encode

encode variable to base64 [&uarr;](#Commands)

```bash
base64Encoded=$(echo -n "${2|stringToEncode,${variableToEncode}|}" | base64)
```



## crypto hash

compute hash of variable (md5, sha, sha1, sha224, sha256, sha384, sha512) [&uarr;](#Commands)

```bash
hash=$(echo -n "$variableToHash" | ${3|md5sum,shasum,sha1sum,sha224sum,sha256sum,sha384sum,sha512sum|} | cut -f1 -d ' ')
```



## date now dayOfMonth

current day of month (1..31) [&uarr;](#Commands)

```bash
dayOfMonth=$(date +%d)
```



## date now dayOfWeek

current day of week name (A: full, a: abbreviated) [&uarr;](#Commands)

```bash
dayOfWeek=$(date +%${2|A,a|})
```



## date now dayOfYear

current day of year (1..366) [&uarr;](#Commands)

```bash
dayOfYear=$(date +%j)
```



## date now short

yyyy/mm/dd [&uarr;](#Commands)

```bash
dateShort=$(date -I) # format: yyyy/mm/dd
```



## date now monthName

current month name (B: full, b: abbreviated) [&uarr;](#Commands)

```bash
monthName=$(date +%${2|B,b|})
```



## date now monthNumber

current month number (1..12) [&uarr;](#Commands)

```bash
monthNumber=$(date +%m)
```



## date now UTC

coordinated Universal Time [&uarr;](#Commands)

```bash
dateUTC=$(date -u)
```



## date now year

current Year (Y: full, y: last two digits) [&uarr;](#Commands)

```bash
year=$(date +%${2|Y,y|})
```



## event CTRL+C , event terminated

register a function (handler) to run on script termination (CTRL+C) [&uarr;](#Commands)

```bash
# CTRL+C event handler
function on_ctrl_c() {
  echo # Set cursor to the next line of '^C'
  tput cnorm # show cursor. You need this if animation is used.
  # i.e. clean-up code here
  exit 1 # Don't remove. Use a number (1-255) for error code.
}

# Put this line at the beginning of your script (after functions used by event handlers).
# Register CTRL+C event handler
trap on_ctrl_c SIGINT
```



## event EXIT

register a function (handler) to run on script exit [&uarr;](#Commands)

```bash
# Exit event handler
function on_exit() {
  tput cnorm # Show cursor. You need this if animation is used.
  # i.e. clean-up code here
  exit 0 # Exit gracefully.
}

# Put this line at the beginning of your script (after functions used by event handlers).
# Register exit event handler.
trap on_exit EXIT
```



## iterate directories

write to a file [&uarr;](#Commands)

```bash
# Make sure path ends with /
for directory in ${1|'/path/to/directory/',"${pathToDirectory}"|}*; do
  if [[ -d "${directory}" && ! -L "${directory}" ]]; then
    echo "${directory"}
  fi
done
```



## directory create

create directory [&uarr;](#Commands)

```bash
mkdir "directory name"
```



## directory create nested

create nested directories [&uarr;](#Commands)

```bash
mkdir -p ${1|"parent dir/child dir","${pathToCreate}"|}
```



## directory delete nested , directory remove nested

delete directory and all contents! [&uarr;](#Commands)

```bash
rm -rf ${1|/path/to/directory,${pathToDirectory}|}
```



## file delete , file remove

delete file(s) [&uarr;](#Commands)

```bash
rm -f ${1|/path/to/file,${pathToFile}|}
```



## file read

read a file [&uarr;](#Commands)

```bash
cat "${1|/path/to/file,${filePath}|}" | while read line; do
  echo "${${2:line}"}
done
```



## file search , search in files , find in files

find files which contain search criteria in given path and below [&uarr;](#Commands)

```bash
result=$(find "${2|/path/to/search,${pathToSearch}|}" -maxdepth ${3|1,2,3,4,5,6,7,8,9|} -type f -exec grep "criteria" {} +)
```



## file write

write to a file [&uarr;](#Commands)

```bash
echo "sample header" > "${2|/path/to/file,${pathToFile}|}"
for line in ${lines[@]}; do
  echo "${line}" >> "${2}"
done
```



## file write multiline

write multiple lines into file [&uarr;](#Commands)

```bash
cat >"${1|/path/to/file,${filePath}|}" <<EOF
first linesecond line...
EOF
```



## file write multiline sudo

write multiple lines into file when sudo permission is required [&uarr;](#Commands)

```bash
cat << EOF | sudo tee "${1|/path/to/file,${filePath}|}" >/dev/null
first linesecond line...
EOF
```



## iterate files

write to a file [&uarr;](#Commands)

```bash
# Make sure path ends with /
for file in ${1|'/path/to/files/',"${pathToFiles}"|}*.{jpg,png}; do
  echo "${file"}
done
```



## file find , directory find

find files (-type f) or directories (-type d) by name or pattern (*.jpg) [&uarr;](#Commands)

```bash
resultArray=($(find "${2|/path/to/search,${pathToSearch}|}" -maxdepth ${3|1,2,3,4,5,6,7,8,9|} -type ${4|f,d|} -name "criteria"))
```



## if directory exists

check if a directory exists [&uarr;](#Commands)

```bash
if [ -d "${1|/path/to/directory,${pathToDirectory}|}" ]; then
  echo "directory \"${1\" exists"}
fi
```



## if file executable

check if file is executable [&uarr;](#Commands)

```bash
if [ -x "${1|/path/to/file,${filePath}|}" ]; then
  echo "file \"${1\" is executable"}
fi
```



## if file exists

check if file exists [&uarr;](#Commands)

```bash
if [ -f "${1|/path/to/file,${filePath}|}" ]; then
  echo "File \"${1\" exists"}
fi
```



## if file link

if given path is a symbolic link [&uarr;](#Commands)

```bash
if [ -h "${1|/path/to/file,${filePath}|}" ]; then
  echo "Path \"${1\" is a symbolic link"}
fi
```



## if file not empty

check if file size is greater than zero [&uarr;](#Commands)

```bash
if [ -s "${1|/path/to/file,${filePath}|}" ]; then
  echo "File \"${1\" is not empty"}
fi
```



## if file readable

check if file readable [&uarr;](#Commands)

```bash
if [ -r "${1|/path/to/file,${filePath}|}" ]; then
  echo "File \"${1\" is readable"}
fi
```



## if file writeable

if file writeable [&uarr;](#Commands)

```bash
if [ -w "${1|/path/to/file,${filePath}|}" ]; then
  echo "File \"${1\" is writeable"}
fi
```



## if file newer

check if file1 is newer than file2 [&uarr;](#Commands)

```bash
if [ "${1|/path/to/file1,${filePath1}|}" -nt "${2|/path/to/file2,${filePath2}|}" ]; then
  echo "Path \"${1\" is newer than path \"${2}\""}
fi
```



## if file older

check if file1 is older than file2 [&uarr;](#Commands)

```bash
if [ "${1|/path/to/file1,${filePath1}|}" -ot "${2|/path/to/file2,${filePath2}|}" ]; then
  echo "Path \"${1\" is older than path \"${2}\""}
fi
```



## if file =

check if files are equal [&uarr;](#Commands)

```bash
if cmp -s "${1|/path/to/file1,${filePath1}|}" "${2|/path/to/file2,${filePath2}|}"; then
  echo "File \"${1\" is equal to file \"${2}\""}
fi
```



## if path exists

if path exists (file, directory, link...) [&uarr;](#Commands)

```bash
if [ -e "${1|/path/to/something,${pathToSomething}|}" ]; then
  echo "Path \"${1\" exists"}
fi
```



## remove old/new files/directories

find and remove files(f)/directories(d) older(+)/newer(-) than x days [&uarr;](#Commands)

```bash
find "${1|/path/to/directory/,${pathToDirectory}|}"* -type ${2|f,d|} -mtime ${3|-,+|}days | xargs rm -f
```



## remove old files

find and remove files older than x days [&uarr;](#Commands)

```bash
find "${1|/path/to/directory,${pathToDirectory}|}" -mtime +days | xargs rm -f
```



## if float = , if double =

if numbers are equal [&uarr;](#Commands)

```bash
if (( $(echo "${num1} == ${num2}" | bc -l) )); then
  echo "equal"
fi
```



## if float > , if double >

if num2 is greater than num2 [&uarr;](#Commands)

```bash
if (( $(echo "${num1} > ${num2}" | bc -l) )); then
  echo "greater"
fi
```



## if float >= , if double >=

if num1 is greater to num2 [&uarr;](#Commands)

```bash
if (( $(echo "${num1} >= ${num2}" | bc -l) )); then
  echo "greater or equal"
fi
```



## if float < , if double <

if num1 is lesser than num2 [&uarr;](#Commands)

```bash
if (( $(echo "${num1} < ${num2}" | bc -l) )); then
  echo "lesser"
fi
```



## if float <= , if double <=

if num1 is lesser or equal to num2 [&uarr;](#Commands)

```bash
if (( $(echo "${num1} <= ${num2}" | bc -l) )); then
  echo "lesser or equal"
fi
```



## if float != , if double !=

if numbers are not equal [&uarr;](#Commands)

```bash
if (( $(echo "${num1} != ${num2}" | bc -l) )); then
  echo "not equal"
fi
```



## fn animation animate

animate frames of animation with interval seconds between frames circular and pendular [&uarr;](#Commands)

```bash
# Usage: animate framesArray interval
function animate () {
  local frames=("$@")

  ((lastIndex=${#frames[@]} - 1))
  local mode=${frames[lastIndex]}
  unset frames[lastIndex]

  ((lastIndex=${#frames[@]} - 1))
  local interval=${frames[lastIndex]}
  unset frames[lastIndex]

  # Comment out next two lines if you are using CTRL+C event handler.
  trap 'tput cnorm; echo' EXIT  trap 'exit 127' HUP INT TERM
  tput civis # hide cursor
  tput sc # save cursor position

  tput civis # hide cursor
  tput sc # save cursor position

  index=0
  max="${#frames[@]}"
  indices=()
  direction="forward"
  forwardIndices=( $(seq 0 1 "${max}") )
  backwardIndices=( $(seq "${max}" -1 0) )

  while true; do
    if [ "${mode}" = "circular" ]; then
      direction="forward"
    elif [ "${mode}" = "pendular" ]; then
      if (( index >= max )); then
        direction="backward"
      elif (( index <= 0 )); then
        direction="forward"
      fi
    else
      echo "Wrong mode! Valid modes: circular, pendular"
      exit 255
    fi

    if [ "${direction}" = "forward" ]; then
      indices=( "${forwardIndices[@]}" )
    else
      indices=( "${backwardIndices[@]}" )
    fi
    

    for index in "${indices[@]}"; do
      tput rc # restore cursor position
      echo "${frames[$index]}"
      sleep "${interval}"
    done
  done
}
```



## fn animation pacman

pacMan animation (eating input text) [&uarr;](#Commands)

```bash
# Usage: pacMan inputString interval pad
# Example: pacman "Hello World" 0.5 "*"
function pacMan () {
  local string="${1}"
  local interval="${2}"
  : "${interval:=0.2}"
  local pad="${3}"
  : "${pad:=.}"
  local length=${#string}
  local padding=""

  # Comment out next two lines if you are using CTRL+C event handler.
  trap 'tput cnorm; echo' EXIT  trap 'exit 127' HUP INT TERM
  tput civis # hide cursor
  tput sc # save cursor position

  for((i=0;i<=length;i++)); do
    tput rc
    echo "${padding}c${string:i:length}"
    sleep "$interval"
    tput rc
    echo "${padding}C${string:i:length}"
    sleep "${interval}"
    padding+="${pad}"
  done

  tput cnorm
  tput rc
  echo "${padding}"
}
```



## fn banner color

print a color banner. [&uarr;](#Commands)

```bash
# Usage: bannerColor "my title" "red" "*"
function bannerColor() {
  case ${2} in
    black) color=0
    ;;
    red) color=1
    ;;
    green) color=2
    ;;
    yellow) color=3
    ;;
    blue) color=4
    ;;
    magenta) color=5
    ;;
    cyan) color=6
    ;;
    white) color=7
    ;;
    *) echo "color is not set"; exit 1
    ;;
  esac
  local msg="${3} ${1} ${3}"
  local edge=$(echo "${msg}" | sed "s/./${3}/g")
  tput setaf ${color}
  tput bold
  echo "${edge}"
  echo "${msg}"
  echo "${edge}"
  tput sgr 0
  echo
}
```



## fn banner simple

function: print a banner with provided title and surrounding character [&uarr;](#Commands)

```bash
# Usage: bannerSimple "my title" "*"
function bannerSimple() {
  local msg="${2} ${1} ${2}"
  local edge=$(echo "${msg}" | sed "s/./"${2}"/g")
  echo "${edge}"
  echo "$(tput bold)${msg}$(tput sgr0)"
  echo "${edge}"
  echo
}
```



## fn import

import functions from other shellscript files [&uarr;](#Commands)

```bash
# Usage: import "mylib"
function import() {
  local file="./lib/${1}.sh"
  if [ -f "${file}" ]; then
    source "${file}"
  else
    echo "Error: Cannot find library at: ${file}"
    exit 1
  fi
}
```



## fn options , fn input choice

provides a list of choices to user and returns the index of selected choice [&uarr;](#Commands)

```bash
# Usage: options=("one" "two" "three"); inputChoice "Choose:" 1 "${options[@]}"; choice=$?; echo "${options[$choice]}"
function inputChoice() {
  echo "${1}"; shift
  echo $(tput dim)-"Change option: [up/down], Select: [ENTER]" $(tput sgr0)
  local selected="${1}"; shift
  ESC=$(echo -e "\033")
  cursor_blink_on()  { tput cnorm; }
  cursor_blink_off() { tput civis; }
  cursor_to()        { tput cup $(($1-1)); }
  print_option()     { echo $(tput sgr0) "$1" $(tput sgr0); }
  print_selected()   { echo $(tput rev) "$1" $(tput sgr0); }
  get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
  key_input()        { read -s -n3 key 2>/dev/null >&2; [[ $key = $ESC[A ]] && echo up; [[ $key = $ESC[B ]] && echo down; [[ $key = "" ]] && echo enter; }
  for opt; do echo; done
  local lastrow=$(get_cursor_row)
  local startrow=$(($lastrow - $#))
  trap "cursor_blink_on; echo; echo; exit" 2
  cursor_blink_off
  : selected:=0
  while true; do
    local idx=0
    for opt; do
      cursor_to $(($startrow + $idx))
      if [ ${idx} -eq ${selected} ]; then
        print_selected "${opt}"
      else
        print_option "${opt}"
      fi
      ((idx++))
    done
    case $(key_input) in
      enter) break;;
      up)    ((selected--)); [ "${selected}" -lt 0 ] && selected=$(($# - 1));;
      down)  ((selected++)); [ "${selected}" -ge $# ] && selected=0;;
    esac
  done
  cursor_to "${lastrow}"
  cursor_blink_on
  echo
  return "${selected}"
}
```



## fn checkbox , fn input multichoice

provides a list of choices to user and returns the index of selected choices [&uarr;](#Commands)

```bash
# Usage: multiChoice "header message" resultArray "comma separated options" "comma separated default values"
# Credit: https://serverfault.com/a/949806
# TODO: 1) Refactoring to return result array 2) Get input options as array
function multiChoice {
  echo "${1}"; shift
  echo $(tput dim)-"Change Option: [up/down], Change Selection: [space], Done: [ENTER]" $(tput sgr0)
  # little helpers for terminal print control and key input
  ESC=$( printf "\033")
  cursor_blink_on()   { printf "$ESC[?25h"; }
  cursor_blink_off()  { printf "$ESC[?25l"; }
  cursor_to()         { printf "$ESC[$1;-1H"; }
  print_inactive()    { printf "$2   $1 "; }
  print_active()      { printf "$2  $ESC[7m $1 $ESC[27m"; }
  get_cursor_row()    { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
  key_input()         {
    local key
    IFS= read -rsn1 key 2>/dev/null >&2
    if [[ $key = ""      ]]; then echo enter; fi;
    if [[ $key = $'\x20' ]]; then echo space; fi;
    if [[ $key = $'\x1b' ]]; then
      read -rsn2 key
      if [[ $key = [A ]]; then echo up;    fi;
      if [[ $key = [B ]]; then echo down;  fi;
    fi
  }
  toggle_option()    {
    local arr_name=$1
    eval "local arr=(\"${${arr_name}[@]}\")"
    local option=$2
    if [[ ${arr[option]} == 1 ]]; then
      arr[option]=0
    else
      arr[option]=1
    fi
    eval $arr_name='("${arr[@]}")'
  }

  local retval=$1
  local options
  local defaults

  IFS=';' read -r -a options <<< "$2"
  if [[ -z $3 ]]; then
    defaults=()
  else
    IFS=';' read -r -a defaults <<< "$3"
  fi

  local selected=()

  for ((i=0; i<${#options[@]}; i++)); do
    selected+=("${defaults[i]}")
    printf "\n"
  done

  # determine current screen position for overwriting the options
  local lastrow=$(get_cursor_row)
  local startrow=$(($lastrow - ${#options[@]}))

  # ensure cursor and input echoing back on upon a ctrl+c during read -s
  trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
  cursor_blink_off

  local active=0
  while true; do
    # print options by overwriting the last lines
    local idx=0
    for option in "${options[@]}"; do
      local prefix="[ ]"
      if [[ ${selected[idx]} == 1 ]]; then
        prefix="[x]"
      fi

      cursor_to $(($startrow + $idx))
      if [ $idx -eq $active ]; then
        print_active "$option" "$prefix"
      else
        print_inactive "$option" "$prefix"
      fi
      ((idx++))
    done

    # user key control
    case $(key_input) in
      space)  toggle_option selected $active;;
      enter)  break;;
      up)     ((active--));
        if [ $active -lt 0 ]; then active=$((${#options[@]} - 1)); fi;;
      down)   ((active++));
        if [ $active -ge ${#options[@]} ]; then active=0; fi;;
    esac
  done

  # cursor position back to normal
  cursor_to $lastrow
  printf "\n"
  cursor_blink_on

  indices=()
  for((i=0;i<${#selected[@]};i++)); do
    if ((${selected[i]} == 1)); then
      indices+=(${i})
    fi
  done

  # eval $retval='("${selected[@]}")'
  eval $retval='("${indices[@]}")'
}
```



## fn math average

calculate average of given integers [&uarr;](#Commands)

```bash
# Usage: average int1 int2 ...
function average () {
  local sum=0
  for int in $@; do
    ((sum += int))
  done
  echo $((sum / $#))
}
```



## fn math factorial

calculate n! [&uarr;](#Commands)

```bash
# Usage: factorial n
factorial ()
{
  if (( $1 < 2 )); then
    echo 1
  else
    echo $(( $1 * $(factorial $(( $1 - 1 ))) ))
  fi
}
```



## fn math fibonacci

calculate Nth fibonacci number [&uarr;](#Commands)

```bash
# Usage: fibonacci n
fibonacci ()
{
  if (($1 < 2)); then 
    echo $1
  else
    echo $(($(fibonacci $(($1 - 1))) + $(fibonacci $(($1 - 2)))))
  fi
}
```



## fn math fibonacci series

array of fibonacci series [&uarr;](#Commands)

```bash
# Usage: fibonacciSeries n
fibonacciSeries ()
{
  fib=()
  fib+=(0)
  fib+=(1)

  for((i=2;i<${1};i++)); do
    fib[i]=$((fib[i-1] + fib[i-2]))
  done

  echo "${fib[@]}"
}
```



## fn math product

calculate product of given integers [&uarr;](#Commands)

```bash
# Usage: product int1 int2 ...
function product () {
  local result=1
  for int in $@; do
    ((result *= int))
  done
  echo ${result}
}
```



## fn math sum

calculate sum of given integers [&uarr;](#Commands)

```bash
# Usage: sum int1 int2 ...
function sum () {
  local result=0
  for int in $@; do
    ((result += int))
  done
  echo ${result}
}
```



## fn progress

progress bar function [&uarr;](#Commands)

```bash
# Usage: progressBar "message" currentStep totalSteps
function progressBar() {
  local   bar='â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ'
  local space='                    '
  local wheel=('\' '|' '/' '-')

  local msg="${1}"
  local current=${2}
  local total=${3}
  local wheelIndex=$((current % 4))
  local position=$((100 * current / total))
  local barPosition=$((position / 5))

  echo -ne "\r|${bar:0:$barPosition}${space:$barPosition:20}| ${wheel[wheelIndex]} ${position}% [ ${msg} ] "
}
```



## fn scan local

scan localhost's port range (tcp/udp) [&uarr;](#Commands)

```bash
# Usage: scan proto host fromPort toPort
function scan () {
  local openPortsArray=()
  for ((port=${3}; port<=${4}; port++)); do
    (echo >/dev/${1}/${2}/${port}) >/dev/null 2>&1 && openPortsArray+=("${port}")
  done
  echo "${openPortsArray[@]}"
}
```



## fn time format seconds

format seconds into days/hours/minutes/seconds [&uarr;](#Commands)

```bash
# Usage: formatSeconds 70 -> 1m 10s
# Credit: https://unix.stackexchange.com/a/27014
function formatSeconds {
  local T=$1
  local D=$((T/60/60/24))
  local H=$((T/60/60$))
  local M=$((T/60`))
  local S=$((T`))
  local result=""

  (( $D > 0 )) && result="${D}d "
  (( $H > 0 )) && result="${result}${H}h "
  (( $M > 0 )) && result="${result}${M}m "
  (( $S > 0 )) && result="${result}${S}s "
  echo -e "${result}" | sed -e 's/[[:space:]]*$//'
}
```



## fn urldecode

decodes encoded URL [&uarr;](#Commands)

```bash
# Usage: urldecode url
# Credit: https://unix.stackexchange.com/a/187256
function urldecode () {
  local urlEncoded="${1//+/ }"
  printf '%b' "${urlEncoded//%/\\\\x}"
}
```



## fn urlencode

encodes URL [&uarr;](#Commands)

```bash
# Usage: urlencode url
# Credit: https://unix.stackexchange.com/a/187256
function urlencode () {
  local length="${#1}"
  for (( i = 0; i < length; i++ )); do
    local c="i:1"
    case "${c}" in
      [a-zA-Z0-9.~_-]) printf "${c}" ;;
      *) printf '%%X' "'${c}" ;;
    esac
  done
}
```



## fn version compare , fn semver compare

function: compares two semvers and returns >, < or = [&uarr;](#Commands)

```bash
# Usage: versionCompare "1.2.3" "1.1.7"
function versionCompare () {
  function subVersion () {
    local len=${#1}
    temp=${1%%"."*} && indexOf=$(echo ${1%%"."*} | echo ${#temp})
    echo -e "0:indexOf"
  }
  function cutDot () {
    local offset=${#1}
    local length=${#2}
    echo -e "((++offset)):length"
  }
  if [ -z "${1}" ] || [ -z "${2}" ]; then
    echo "=" && exit 0
  fi
  local v1=$(echo -e "${1}" | tr -d '[[:space:]]')
  local v2=$(echo -e "${2}" | tr -d '[[:space:]]')
  local v1Sub=$(subVersion $v1)
  local v2Sub=$(subVersion $v2)
  if (( v1Sub > v2Sub )); then
    echo ">"
  elif (( v1Sub < v2Sub )); then
    echo "<"
  else
    versionCompare $(cutDot $v1Sub $v1) $(cutDot $v2Sub $v2)
  fi
}
```



## fx animation animate

call animate function to start animation [&uarr;](#Commands)

```bash
# Usage: animate framesArray interval
animate "${frames[@]}" ${2|0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1|} ${3|circular,pendular|}
```



## fx animation pacman

call pacMan animation (eating input text) function [&uarr;](#Commands)

```bash
# Usage: pacMan inputString interval pad
pacMan "Hello World" ${2|0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1|} "${3|.,*,+,-,~,x,o|}"
```



## fx banner color

call bannerColor function [&uarr;](#Commands)

```bash
# Usage: bannerColor "my title" "red" "*"
bannerColor "my title" "${2|black,red,green,yellow,blue,magenta,cyan,white|}" "${3|*,:,+,.,x,o,$|}"
```



## fx banner simple

call bannerSimple function [&uarr;](#Commands)

```bash
# Usage: bannerSimple "my title" "*"
bannerSimple "my title" "${2|*,:,+,.,x,o,$|}"
```



## fx import

import functions from other shellscript files located in a directory (default: lib) relative to current file [&uarr;](#Commands)

```bash
# Usage: import "filename"
import "libname"
```



## fx options , fx input choice

call input choice function [&uarr;](#Commands)

```bash
# Usage: options=("one" "two" "three"); inputChoice "Choose:" 1 "${options[@]}"; choice=$?; echo "${options[$choice]}"
options=(${2:"one" "two" "three"})
inputChoice "Choose:" ${4|0,1,2,3,4,5,6,7,8,9|} "${${1}[@]}"; choice=$?
echo "${${1}[$choice]}" selected
```



## fx checkbox , fx input multichoice

call input multichoice function [&uarr;](#Commands)

```bash
# Usage: multiChoice "header message" resultArray "comma separated options" "comma separated default values"
multiChoice "Select options:" ${2:result} "One 1;Two 2;Three 3" "1;0;1"
echo "${${2}[@]}"
```



## fx math fibonacci

calculate Nth fibonacci number [&uarr;](#Commands)

```bash
# Usage: fibonacci n
result=$(fibonacci n)
```



## fx math average

call math average function [&uarr;](#Commands)

```bash
# Usage: average int1 int2 ...
result=$(average ${int1} ${${2:int2}} ${int3})
```



## fx math factorial

calculate n! [&uarr;](#Commands)

```bash
# Usage: factorial n
result=$(factorial n)
```



## fx math fibonacci series

array of fibonacci series [&uarr;](#Commands)

```bash
# Usage: fibonacciSeries n
result=($(fibonacciSeries n))
echo "${${1}[@]}"
```



## fx math product

call math product function [&uarr;](#Commands)

```bash
# Usage: product int1 int2 ...
result=$(product ${int1} ${${2:int2}} ${int3})
```



## fx math sum

call math sum function [&uarr;](#Commands)

```bash
# Usage: sum int1 int2 ...
result=$(sum ${int1} ${${2:int2}} ${int3})
```



## fx progress

call progress bar function [&uarr;](#Commands)

```bash
# Usage: progressBar "message" currentStep totalSteps
totalSteps=${2:100}

for ((currentStep=${4:1}; ${3} <= ${1}; ${3}++)); do
  sleep 0.1 # simulating one step of job
  progressBar "Installing foo..." ${${3}} ${${1}}
done
echo
```



## fx scan local

call scan function to scan localhost over a port range [&uarr;](#Commands)

```bash
# Usage: scan proto host fromPort toPort
openPorts=( $(scan ${1|tcp,udp|} "${2|localhost,127.0.0.1,::1|}" fromPort ${4:toPort}) )
echo "${openPorts[@]"}
```



## fx time format seconds

call formatSeconds function [&uarr;](#Commands)

```bash
# Usage: formatSeconds 70 -> 1m 10s
result=($(formatSeconds seconds))
echo ${${1}[@]}
```



## fx urldecode

call urldecode function [&uarr;](#Commands)

```bash
# Usage: urldecode url
urldecode "${1|encodedUrl,${encodedUrl}|}"
```



## fx urlencode

call urlencode function [&uarr;](#Commands)

```bash
# Usage: urlencode url
urlencode "${1|url,${url}|}"
```



## fx version compare , fx semver compare

call versionCompare function [&uarr;](#Commands)

```bash
# Usage: versionCompare "1.2.3" "1.1.7"
versionCompare "major.${2:minor}.patch" "${4:major}.minor.${6:patch}"
```



## ftp delete file

delete specified file from ftp server [&uarr;](#Commands)

```bash
curl ftp://user:${2:password}@ipOrDomain/${4:path}/fileToDelete -Q "DELE fileToDelete"
```



## ftp download

download specified file from ftp server [&uarr;](#Commands)

```bash
curl ftp://user:${2:password}@ipOrDomain/${4:filePathOnServer}/
```



## ftp list

get the list of files on the ftp server at specific path [&uarr;](#Commands)

```bash
curl ftp://user:${2:password}@ipOrDomain/${4:directoryPathOnServer}/
```



## ftp rename

rename specified file/directory on ftp server [&uarr;](#Commands)

```bash
curl ftp://user:${2:password}@ipOrDomain/path/ -Q "-RNFR path/${5:renameFrom}" -Q "-RNTO path/renameTo"
```



## ftp upload

upload specified file to ftp server [&uarr;](#Commands)

```bash
curl -T fileToUpload ftp://user:${3:password}@ipOrDomain/${5:directoryPathOnServer}/
```



## function arguments , func args

function all arguments array [&uarr;](#Commands)

```bash
echo "$@"
```



## function arguments count , func args count

number of function arguments [&uarr;](#Commands)

```bash
echo $#
```



## function , func

function [&uarr;](#Commands)

```bash
function name () {
  echo "$1" # arguments are accessible through $1, $2,...
}
```



## function return value , func return value

last function/command return code [&uarr;](#Commands)

```bash
echo "$?"
```



## git branch create

create branch locally and switch into it. [&uarr;](#Commands)

```bash
git checkout -b branchName
```



## git branch delete local

delete local branch. [&uarr;](#Commands)

```bash
git branch --delete localBranch
```



## git branch delete remote

delete remote branch. [&uarr;](#Commands)

```bash
git push origin --delete remoteBranch
```



## git branch list

list all branches. [&uarr;](#Commands)

```bash
git branch
```



## git branch push

push branch to remote. [&uarr;](#Commands)

```bash
git push origin branchName
```



## git branch rename

rename current branch. [&uarr;](#Commands)

```bash
git branch -m newName
```



## git changes revert

revert tracked changes [&uarr;](#Commands)

```bash
git checkout .
```



## git clone

clone remote repository to local machine. [&uarr;](#Commands)

```bash
git clone https://github.com/${2:user}/repository.git
```



## git clone branch

clone a remote branch to local machine. [&uarr;](#Commands)

```bash
git clone -b branchName https://github.com/${3:user}/repository.git
```



## git commit

commit changes. [&uarr;](#Commands)

```bash
git commit -m "commit message"
```



## git commit list notPushed

list non pushed commits. [&uarr;](#Commands)

```bash
git log origin/master..HEAD
```



## git commit search

search for a commit which contains searchCriteria. [&uarr;](#Commands)

```bash
git log --all --grep='searchCriteria'
```



## git commit undo

undo last N commits (soft: preserve local changes, hard: delete local changes [&uarr;](#Commands)

```bash
git reset --${1|soft,hard|} HEAD~${2|1,2,3,4,5,6,7,8,9|}
```



## git config list

list git configurations. [&uarr;](#Commands)

```bash
git config --list
```



## git config set

configure git. [&uarr;](#Commands)

```bash
git config --${1|local,global|} ${2|user.name,user.email|} "value"
```



## git patch apply

apply a patch from file [&uarr;](#Commands)

```bash
git apply < "${1|/path/to/patch1.patch,${patchPath}|}"
```



## git patch create

create a patch from changes [&uarr;](#Commands)

```bash
git diff > "${1|/path/to/patch1.patch,${patchPath}|}"
```



## git remote list

list all remotes [&uarr;](#Commands)

```bash
git remote
```



## git remote urlChange

change remote url [&uarr;](#Commands)

```bash
git remote set-url origin https://github.com/${2:user}/repository.git
```



## git remote urlAdd

add remote url [&uarr;](#Commands)

```bash
git remote add origin https://github.com/${2:user}/repository.git
```



## git tag commit , git commit tag

tag a commit [&uarr;](#Commands)

```bash
git tag -a release/1.0.0 -m "1.0.0 release"
```



## git tag list

list all tags [&uarr;](#Commands)

```bash
git tag
```



## git tag remote delete

delete tag from remote [&uarr;](#Commands)

```bash
git push --delete origin tagName && git push origin :tagName
```



## git tag remote push

push tag to remote [&uarr;](#Commands)

```bash
git push origin tagName
```



## http cookie

send http request with cookies, using curl [&uarr;](#Commands)

```bash
curl --request ${1|GET,POST,DELETE,PUT|} -sL \
  --user-agent '${2|Shellman,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/58.0.3029.110 Safari/537.36,Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393|}' \
  --cookie ${3|'key=value',"${key}=${value}"|} \
  --url ${4|'http://example.com',"${url}"|}
```



## http download

download from url and save to /path/to/file, using curl [&uarr;](#Commands)

```bash
curl --request ${1|GET,POST|} -sL \
  --user-agent '${2|Shellman,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/58.0.3029.110 Safari/537.36,Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393|}' \
  --output ${3|'/path/to/file',"${pathToFile}"|} \
  --url ${4|'http://example.com/file.zip',"${downloadUrl}"|}
```



## http GET , http DELETE

send http GET/DELETE request using curl [&uarr;](#Commands)

```bash
curl --request ${1|GET,DELETE|} -sL \
  --user-agent '${2|Shellman,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/58.0.3029.110 Safari/537.36,Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393|}' \
  --url ${3|'http://example.com',"${url}"|}
```



## http header

send http request with custom header, using curl [&uarr;](#Commands)

```bash
curl --request ${1|GET,POST,DELETE,PUT|} -sL \
  --user-agent '${2|Shellman,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/58.0.3029.110 Safari/537.36,Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393|}' \
  --header ${3|'key: value',"${key}": "${value}"|} \
  --url ${4|'http://example.com',"${url}"|}
```



## http POST , http PUT

send data with http POST/PUT, using curl [&uarr;](#Commands)

```bash
curl --request ${1|POST,PUT|} -sL \
  --user-agent '${2|Shellman,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/58.0.3029.110 Safari/537.36,Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393|}' \
  --url ${3|'http://example.com',"${url}"|} \
  --data ${4|'key=value',"${key}"="${value}"|}
```



## http POST file

send file with http POST, using curl [&uarr;](#Commands)

```bash
curl --request POST -sL \
  --user-agent '${1|Shellman,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/58.0.3029.110 Safari/537.36,Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML\, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393|}' \
  --url ${2|'http://example.com',"${url}"|} \
  --form ${3|'key=value',"${key}"="${value}"|} \
  --form ${4|'file=@/path/to/file',file=@"${pathToFile}"|}
```



## input password

get text as input from user without showing characters [&uarr;](#Commands)

```bash
echo "Please enter your password: "
read -s password
echo "${password"}
```



## input text , ask question

get text as input from user [&uarr;](#Commands)

```bash
read -ep "Question here? " -i "Default answer" answer
echo "${answer"}
```



## if int =

if integers are equal [&uarr;](#Commands)

```bash
if (( int1 == ${2:int2} )); then
  echo "equal"
fi
```



## if int >

if int1 is greater than int2 [&uarr;](#Commands)

```bash
if (( int1 > ${2:int2} )); then
  echo "greater"
fi
```



## if int >=

if int1 is greater or equal to int2 [&uarr;](#Commands)

```bash
if (( int1 >= ${2:int2} )); then
  echo "greater or equal"
fi
```



## if int <

if int1 is lesser than int2 [&uarr;](#Commands)

```bash
if (( int1 < ${2:int2} )); then
  echo "lesser"
fi
```



## if int <=

if int1 is lesser or equal to int2 [&uarr;](#Commands)

```bash
if (( int1 <= ${2:int2} )); then
  echo "lesser or equal"
fi
```



## if int !=

if integers are not equal [&uarr;](#Commands)

```bash
if (( int1 != ${2:int2} )); then
  echo "not equal"
fi
```



## for i

for loop by index [&uarr;](#Commands)

```bash
for((i=0;i<n;i++)); do
  echo "${i"}
done
```



## for ij

for loop by index [&uarr;](#Commands)

```bash
for((i=0;i<n;i++)); do
  for((j=0;j<m;j++)); do
    echo "${i, ${j}"}
  done
done
```



## for in collection

for loop in collection [&uarr;](#Commands)

```bash
for item in {"Hello World!",a,bc,1372}; do
  echo "${item}"
done
```



## for in column

for loop in collection [&uarr;](#Commands)

```bash
for col in $(docker images | awk '{ print $1":"$2 }'); do
  echo "${${1:col}" | cut -d ':' -f 1}
  echo "${${1:col}" | cut -d ':' -f 2}
done
```



## for in range

for loop in collection [&uarr;](#Commands)

```bash
for item in ${2|{a..z},{0..20}|}; do
  echo "${item}"
done
```



## if

if [&uarr;](#Commands)

```bash
if [ condition ]; then
   # if body
elif [ condition ]; then
   # else if body
else
   # else body
fi
```



## iff

if condition is true then run command (short circuit) [&uarr;](#Commands)

```bash
[ condition ] && command
```



## iff not

if condition is false then run command (short circuit) [&uarr;](#Commands)

```bash
[ condition ] || command
```



## loop infinite

infinite loop [&uarr;](#Commands)

```bash
while true; do
  echo "infinite loop"  sleep 1s
done
```



## switch case

switch case [&uarr;](#Commands)

```bash
case "${item}" in
  1)
    echo "item = 1"
  ;;
  2|3)
    echo "item = 2 or item = 3"
  ;;
  *)
    echo "default (none of above)"
  ;;
esac
```



## loop until

until loop [&uarr;](#Commands)

```bash
until [ condition ]; do
  # body
done
```



## loop while

while loop [&uarr;](#Commands)

```bash
while [ condition ]; do
  # body
done
```



## ip local IPs

array of local IPs [&uarr;](#Commands)

```bash
IPs=$(hostname -I)
```



## ip info

public ip information [&uarr;](#Commands)

```bash
info=$(curl -s ipinfo.io/${2|ip,city,region,country,loc,postal,org|})
```



## ip public

public ip address [&uarr;](#Commands)

```bash
publicIp=$(curl -s ${2|bot.whatismyipaddress.com,ident.me,ipecho.net/plain,icanhazip.com,ifconfig.me,api.ipify.org,ipinfo.io/ip|})
```



## math +

add two variables [&uarr;](#Commands)

```bash
result=$((${2:int1} + int2))
```



## math const ð›¾

math Euler-Mascheroni constant [&uarr;](#Commands)

```bash
MATH_GAMMA='0.57721566490153286060651209008240243'
```



## math const e

math Napier's constant [&uarr;](#Commands)

```bash
MATH_NAPIER='2.71828182845904523536028747135266249'
```



## math const Î©

math Omega constant [&uarr;](#Commands)

```bash
MATH_OMEGA='0.56714329040978387299996866221035554'
```



## math const Ï•

math golden ration constant [&uarr;](#Commands)

```bash
MATH_GOLDEN_RATIO='1.61803398874989484820458683436563811'
```



## math const Ï€

math PI constant [&uarr;](#Commands)

```bash
MATH_PI='3.14159265358979323846264338327950288'
```



## math --

decrement integer variable [&uarr;](#Commands)

```bash
((${1|int--,--int|}))
```



## math /

divide int1 by int2 as integers and returns whole part [&uarr;](#Commands)

```bash
result=$((${2:int1} / int2))
```



## math /=

divide int1 by int2 and assign the whole part to int1 [&uarr;](#Commands)

```bash
((int1 /= ${2:int2}))
```



## expr , arithmetic

arithmetic operations on integers [&uarr;](#Commands)

```bash
result=$(expr ${int1} ${3|+,-,\*,/,%|} ${int2})
```



## math ++

increment integer variable by 1 [&uarr;](#Commands)

```bash
((${1|int++,++int|}))
```



## let

arithmetic operations on integers [&uarr;](#Commands)

```bash
let "result = ${2:int1} ${3|+,-,*,/,%|} int2"
```



## math -=

subtract int2 from int1 and assign the result to int1 [&uarr;](#Commands)

```bash
((int1 -= ${2:int2}))
```



## math %

reminder of dividing int1 by int2 (modulus) [&uarr;](#Commands)

```bash
result=$((${2:int1} % int2))
```



## math %=

divide int1 by int2 and assign the reminder to int1 [&uarr;](#Commands)

```bash
((int1 %= ${2:int2}))
```



## math *

multiply int1 by int2 [&uarr;](#Commands)

```bash
result=$((${2:int1} * int2))
```



## math *=

multiply int1 by int2 and assign the result to int1 [&uarr;](#Commands)

```bash
((int1 *= ${2:int2}))
```



## math +=

add int1 and int2 and assign the result to int1 [&uarr;](#Commands)

```bash
((int1 += ${2:int2}))
```



## math ^

exponentiate base to power [&uarr;](#Commands)

```bash
result=$((${2:base} ** power))
```



## math 0.00

math operations with up to scale decimal places precision [&uarr;](#Commands)

```bash
result=$(echo "scale=${2|0,1,2,3,4,5,6,7,8,9|};(${num1} ${4|+,-,*,/,^|} ${num2})" | bc)
```



## math random

generate random integer x such as min <= x <= max [&uarr;](#Commands)

```bash
result=$((${2:min} + RANDOM % $((max-${2:min}))))
```



## math âˆš , math sqrt

square root of var up to scale decimal places [&uarr;](#Commands)

```bash
result=$(echo "scale=${2|0,1,2,3,4,5,6,7,8,9|};sqrt(${3|num,${num}|})" | bc)
```



## math -

subtract int2 from int1 [&uarr;](#Commands)

```bash
result=$((${2:int1} - int2))
```



## am I not root , am I not sudo

check if script is not running as root (sudo) [&uarr;](#Commands)

```bash
if (( $(id -u) != 0 )); then
  echo "I'm not root"
fi
```



## am I root , am I sudo

check if script is running as root (sudo) [&uarr;](#Commands)

```bash
if (( $(id -u) == 0 )); then
  echo "I'm root"
fi
```



## animation frame

define animation frame [&uarr;](#Commands)

```bash
# Your frames need to have the exact same width and height.
# If they are different in size, fill unused space with `space`s (no `TAB`s).
IFS='' read -r -d '' frames[${2|1,2,3,4,5,6,7,8,9|}] <<"EOF"
# Frame here
EOF
```



## argument parsing , parse args

parse command line arguments (flags/switches) [&uarr;](#Commands)

```bash
POSITIONAL=()
while [[ $# > 0 ]]; do
  case "${1}" in
    -f|--flag)
    echo flag: "${1}"
    shift # shift once since flags have no values
    ;;
    -s|--switch)
    echo "switch: ${1} with value: ${2}"
    shift 2 # shift twice to bypass switch and its value
    ;;
    *) # unknown flag/switch
    POSITIONAL+=("${1}")
    shift
    ;;
  esac
done
set -- "${POSITIONAL[@]}" # restore positional params
```



## echo array

print array elements [&uarr;](#Commands)

```bash
echo ${myArray[@]}
```



## echo text , print text

print text, variable or both [&uarr;](#Commands)

```bash
echo 'text here'
```



## echo variable , print variable

print text, variable or both [&uarr;](#Commands)

```bash
echo "${${1|result,variable,X|}}"
```



## exit code

provide an exit code on error [&uarr;](#Commands)

```bash
exit ${1|0,1,2,3,4,5,6,7,8,9,255|}
```



## region , section

comment out a special region (i.e. variable declarations) [&uarr;](#Commands)

```bash
# >>>>>>>>>>>>>>>>>>>>>>>> ${1|functions,event handlers,variables,frames,argument parsing,main code|} >>>>>>>>>>>>>>>>>>>>>>>>
$0
# <<<<<<<<<<<<<<<<<<<<<<<< ${1} <<<<<<<<<<<<<<<<<<<<<<<<
```



## shebang , bash , first line

shell shebang [&uarr;](#Commands)

```bash
#!/usr/bin/env ${1|bash,node,perl,php,python,python3,ruby|}
```



## sleep

sleep for a specified amount of time (s: second, m: minute, h: hour, d: day) [&uarr;](#Commands)

```bash
sleep 30${2|s,m,h,d|}
```



## stopwatch elapsed

elapsed time [&uarr;](#Commands)

```bash
stopwatchElapsedTotalSeconds=$((stopwatchEndTime - stopwatchStartTime))
stopwatchElapsedMinutes=$((stopwatchElapsedTotalSeconds / 60))
stopwatchElapsedSeconds=$((stopwatchElapsedTotalSeconds % 60))
echo "elapsed ${stopwatchElapsedMinutes minutes and ${stopwatchElapsedSeconds} seconds}."
```



## stopwatch start

start stopwatch [&uarr;](#Commands)

```bash
stopwatchStartTime=$(date +%s)
```



## stopwatch stop

stop stopwatch [&uarr;](#Commands)

```bash
stopwatchEndTime=$(date +%s)
```



## summary

script summary [&uarr;](#Commands)

```bash
# Title:         title
# Description:   description
# Author:        author <email>
# Date:          yyyy-mm-dd
# Version:       1.0.0

# Exit codes
# ==========
# 0   no error
# 1   script interrupted
# 2   ${7:error description}
```



## timeout

run command within a time frame [&uarr;](#Commands)

```bash
timeout seconds ${2:command}
```



## color black

write in black [&uarr;](#Commands)

```bash
echo $(tput setaf 0)"black text"$(tput sgr0)
```



## color blue

write in blue [&uarr;](#Commands)

```bash
echo $(tput setaf 4)"blue text"$(tput sgr0)
```



## color cyan

write in cyan [&uarr;](#Commands)

```bash
echo $(tput setaf 6)"cyan text"$(tput sgr0)
```



## color green

write in green [&uarr;](#Commands)

```bash
echo $(tput setaf 2)"green text"$(tput sgr0)
```



## color magenta

write in magenta [&uarr;](#Commands)

```bash
echo $(tput setaf 5)"magenta text"$(tput sgr0)
```



## color red

write in red [&uarr;](#Commands)

```bash
echo $(tput setaf 1)"red text"$(tput sgr0)
```



## color white

write in white [&uarr;](#Commands)

```bash
echo $(tput setaf 7)"white text"$(tput sgr0)
```



## color yellow

write in yellow [&uarr;](#Commands)

```bash
echo $(tput setaf 3)"yellow text"$(tput sgr0)
```



## format bold

write in bold [&uarr;](#Commands)

```bash
echo $(tput bold)"bold text"$(tput sgr0)
```



## format dim

write in dim [&uarr;](#Commands)

```bash
echo $(tput dim)"dimmed text"$(tput sgr0)
```



## format italic

write in italic [&uarr;](#Commands)

```bash
echo $(tput sitm)"italic text"$(tput sgr0)
```



## format reverse

write in reverse [&uarr;](#Commands)

```bash
echo $(tput rev)"reversed text"$(tput sgr0)
```



## process ID(s)

find process ID(s) aka PIDs [&uarr;](#Commands)

```bash
processIDsArray=($(pgrep processName))
echo "${${1[@]}"}
```



## process instances

list processes [&uarr;](#Commands)

```bash
processInstances=$(ps -A | grep "${processName}")
```



## process kill

kill process by name [&uarr;](#Commands)

```bash
sudo kill -9 $(pgrep processName)
```



## process list all

list processes [&uarr;](#Commands)

```bash
ps -A
```



## process Name by ID

find process name by it's ID(s) [&uarr;](#Commands)

```bash
processName=$(ps -p ${pid} -o comm=)
```



## string concat , string + string

concatenate two strings [&uarr;](#Commands)

```bash
string="${${2:string1}}${string2}"
```



## string contains , if string contains

check whether string contains substring [&uarr;](#Commands)

```bash
if [[ "${string}" = *${substring}* ]]; then
  echo "${${1:string} contains: ${substring}"}
fi
```



## string indexOf

first index of substring in a string [&uarr;](#Commands)

```bash
temp=${string%%${${2:substring}}*} && index=${#temp}
echo "index of \"${${2:substring}\" in \"${string}\" is ${index}"}
```



## if string empty

if string is empty [&uarr;](#Commands)

```bash
if [ -z "${string}" ]; then
  echo "empty string"
fi
```



## if string = , string equal

if strings are equal [&uarr;](#Commands)

```bash
if [ "${string1}" = "${string2}" ]; then
  echo "The two strings are the same"
fi
```



## if string not empty

if string is not empty [&uarr;](#Commands)

```bash
if [ -n "${string}" ]; then
  echo "string is not empty"
fi
```



## if string != , string not equal

if strings are not equal [&uarr;](#Commands)

```bash
if [ "${string1}" != "${string2}" ]; then
  echo "The two strings are different"
fi
```



## string length

length of string in characters [&uarr;](#Commands)

```bash
length=${#${2:string}}
```



## string random

random string from provided characters with desired length (default: 8) [&uarr;](#Commands)

```bash
randomString=$(tr -dc A-Za-z0-9 </dev/urandom | head -c 8 ; echo '')
```



## string replace

find all occurrences of a substrings and replace them [&uarr;](#Commands)

```bash
replaced=$(echo -e "${string}" | sed -e ${3|'s/find/replace/g',"s/${find}/${replace}/g"|})
```



## string reverse

reverse string characters [&uarr;](#Commands)

```bash
reversed=$(echo -e "${string}" | rev)
```



## string substring

part of the string from offset (zero indexed) up to characters length [&uarr;](#Commands)

```bash
substring=$(echo -e "${string:${${3:offset}}:${length}}")
```



## string substring count , string substring frequency

frequency of a substring in a string [&uarr;](#Commands)

```bash
tmp="${string//$substring}" && frequency=$(((${#${1}} - ${#tmp}) / ${#substring}))
echo "${${3:frequency}"}
```



## string toLower

convert string to lowercase [&uarr;](#Commands)

```bash
toLower=$(echo -e "${string}" | tr '[:upper:]' '[:lower:]')
```



## string toUpper

convert string to uppercase [&uarr;](#Commands)

```bash
toUpper=$(echo -e "${string}" | tr '[:lower:]' '[:upper:]')
```



## string trim

remove leading and trailing white space(s) [&uarr;](#Commands)

```bash
trimmed=$(echo -e "${string}" |  sed -e 's/^[[:space:]]*//' | sed -e 's/[[:space:]]*$//')
```



## string trim all

remove all white space(s) [&uarr;](#Commands)

```bash
trimmed=$(echo -e "${string}" | tr -d '[[:space:]]')
```



## string trim left

remove leading white space(s) [&uarr;](#Commands)

```bash
trimmed=$(echo -e "${string}" | sed -e 's/^[[:space:]]*//')
```



## string trim right

remove trailing white space(s) [&uarr;](#Commands)

```bash
trimmed=$(echo -e "${string}" | sed -e 's/[[:space:]]*$//')
```



## system distro codename

OS codename (i.e. Focal Fossa) [&uarr;](#Commands)

```bash
distroCodeName=$(lsb_release -c | awk '{print $2}')
echo "${${1:distroCodeName}"}
```



## system distro name

OS ID (i.e. Ubuntu) [&uarr;](#Commands)

```bash
distroName=$(lsb_release -i | awk '{print $3}')
echo "${${1:distroName}"}
```



## system distro version

OS Release (i.e. 20.04.2) [&uarr;](#Commands)

```bash
distroVersion=$(lsb_release -r | awk '{print $2}')
echo "${${1:distroVersion}"}
```



## system kernel name

OS kernel name (i.e. Linux) [&uarr;](#Commands)

```bash
kernelName=$(uname -s)
echo "${${1:kernelName}"}
```



## system kernel release

OS kernel release (i.e. 4.4.0-140-generic) [&uarr;](#Commands)

```bash
kernelRelease=$(uname -r)
echo "${${1:kernelRelease}"}
```



## system memory info

system memory information in kilobytes (KB) [&uarr;](#Commands)

```bash
sysMemory${1|MemTotal,MemFree,MemAvailable,Cached,Buffers,Active,Inactive,SwapTotal,SwapFree,SwapCached|}=$(cat /proc/meminfo | grep '${1}' | awk '{print $2}' | head -n 1)
echo "${sysMemory${1}"}
```



## system processor architecture , system cpu architecture , system cpu arch

processor architecture (i.e. x86_64) [&uarr;](#Commands)

```bash
arch=$(lscpu | grep 'Architecture' |awk '{print $2}' | head -n 1)
echo "${${1:arch}"}
```



## system processor count , system cpu count

processor count (cores) [&uarr;](#Commands)

```bash
cores=$(lscpu | grep 'CPU(s)' |awk '{print $2}' | head -n 1)
echo "${${1:cores}"}
```



## system processor model , system cpu model

processor model name (i.e. Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz) [&uarr;](#Commands)

```bash
cpuModel=$(lscpu | grep 'Model name' |cut -d ' ' -f 3- | sed -e 's/^[[:space:]]*//')
echo "${${1:cpuModel}"}
```



## system processor type , system cpu type

OS processor type (i.e. x86_64) [&uarr;](#Commands)

```bash
cpuType=$(uname -p)
echo "${${1:cpuType}"}
```



## service manage , systemd manage

manage service operations [&uarr;](#Commands)

```bash
sudo systemctl ${1|enable,disable,start,stop,reload,restart,status|} ${2|'serviceName',"${serviceName}"|}
```



## system uptime

system uptime. -p: --pretty, -s: since [&uarr;](#Commands)

```bash
systemUptime=$(uptime ${2|-p,-s|})
echo "${${1}"}
```



## system uptime seconds

system uptime in seconds. [&uarr;](#Commands)

```bash
# Use 'fn time format seconds' snippet for formatting
systemUptime=$(awk '{print $1}' /proc/uptime)
echo "${${1}"}
```



## time seconds epoch

seconds since epoch (1970-01-01 00:00:00) [&uarr;](#Commands)

```bash
timeNowSecondsEpoch=$(date +%s)
echo "${${1}"}
```



## time now local

current local time (R: 24hrs, r: 12hrs) [&uarr;](#Commands)

```bash
timeNowLocal=$(date +%${2|R,r|})
echo "${${1}"}
```



## time now UTC

current UTC time [&uarr;](#Commands)

```bash
timeNowUTC=$(date -u +%R)
echo ${${1}}
```



## variable assign , variable set

assign a value or another variable to a new variable [&uarr;](#Commands)

```bash
variable=${2|'value',"${anotherVariable}"|}
```



## variable default value , assign if empty

assign default value to variable if variable is empty otherwise assign null [&uarr;](#Commands)

```bash
: "${variable:=${2:defaultValue}}"
```



## var , variable read , variable expand

read the value of a variable [&uarr;](#Commands)

```bash
"${${1|result,variable|}}"
```

